# rebinded configuration
# Place at ~/.config/rebinded/config.toml

# Strategy definitions
# Strategies control how key events are processed before action execution.
#
# gated_hold: Requires key to be held before first activation, then allows
#             rapid re-presses. Good for scroll wheel tilt buttons to prevent
#             accidental activation while allowing intentional rapid skipping.
#
#             Optional "diverts" field: While a key is held (either waiting for
#             gate or already activated), receiving a divert event (e.g., scroll)
#             transitions to "diverted" mode and executes the mapped action.
#             The original action is cancelled (if pending) or released (if active).
#             Scrolling while tilted = volume control instead of track skip.

[strategies.scroll]
type = "gated_hold"
initial_hold_ms = 110      # Must hold for 110ms before first activation
repeat_window_ms = 2000    # After release, quick re-presses activate immediately for 2 seconds
# Diverts: while holding a key bound to this strategy, these events trigger alternative actions
# instead of the normal gated hold behavior. Useful for volume control while track-skipping.
diverts = { scroll_up = "volume_up", scroll_down = "volume_down" }

# Key bindings
# Keys are case-insensitive: F13, f13, etc.
# Actions: media_play_pause, media_next, media_previous, media_stop,
#          volume_up, volume_down, volume_mute,
#          browser_back, browser_forward, passthrough, block

# Play/Pause - simple action, no conditions
[bindings.F13]
action = "media_play_pause"

# Open for games/scripts - passes F14 through unchanged
[bindings.F14]
action = "passthrough"

# Previous track - uses scroll strategy to prevent accidental bumps
[bindings.F15]
action = "media_previous"
strategy = "scroll"

# Next track - uses scroll strategy
[bindings.F16]
action = "media_next"
strategy = "scroll"

# Forward - context-sensitive: browser forward in Vivaldi/Firefox, passthrough elsewhere
[bindings.f17]
action = [
    { condition = { window = { title = "*Vivaldi*" } }, action = "browser_forward" },
    { condition = { window = { title = "*Firefox*" } }, action = "browser_forward" },
    { condition = { window = { binary = "vivaldi*" } }, action = "browser_forward" },
    { condition = { window = { binary = "firefox*" } }, action = "browser_forward" },
    # No condition = implicit passthrough
]

# Back - context-sensitive
[bindings.F18]
action = [
    { condition = { window = { title = "*Vivaldi*" } }, action = "browser_back" },
    { condition = { window = { title = "*Firefox*" } }, action = "browser_back" },
    { condition = { window = { binary = "vivaldi*" } }, action = "browser_back" },
    { condition = { window = { binary = "firefox*" } }, action = "browser_back" },
]

# Open for games/scripts
[bindings.f19]
action = "passthrough"

# Examples of other condition patterns:

# Block a key when a specific game is running
# [bindings.F20]
# action = [
#     { condition = { window = { binary = "game.exe" } }, action = "block" },
# ]

# Use negation to enable only when NOT in a game
# [bindings.F21]
# action = [
#     { condition = { window = { not_binary = "*game*" } }, action = "media_play_pause" },
# ]

# Combine positive and negative conditions (AND logic)
# [bindings.F22]
# action = [
#     { condition = { window = { title = "*YouTube*", not_binary = "discord*" } }, action = "media_play_pause" },
# ]
